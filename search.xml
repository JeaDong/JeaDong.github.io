<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PyQt5笔记]]></title>
    <url>%2FJeaDong.github.io%2F2018%2F06%2F13%2FPyQt5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[12345import sysfrom PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QMessageBox, QLineEditfrom PyQt5.QtGui import QIconfrom random import randint#上面的内容都是为了引入所需要的模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Example(QWidget): #Example在初始化的时候需要继承Qwidget所需要属性 def __init__(self): super().__init__()#调用了QWidget的__init__ self.initUI() self.num = randint(1, 100)#返回1-100的一个这个整数 def initUI(self): self.setGeometry(300, 300, 300, 220) #setGeometry有4个参数，前两个表示x,y的坐标。后两个表示所要显示的内容的宽高，单位是px self.setWindowTitle('学点编程吧--猜数字') self.setWindowIcon(QIcon('xdbcb8.ico')) #setWindowIcon可以给程序设置一个小图标，位于左上角 self.bt1 = QPushButton('我猜', self) #QPushButton添加一个按钮，第二个参数是为了绑定example这个实例上， #只有example能调用这个按钮 self.bt1.setGeometry(115, 150, 70, 30) self.bt1.setToolTip('&lt;b&gt;点击这里猜数字&lt;/b&gt;') #setToolTip可以在你鼠标移动到这个按钮的时候出现提示信息 self.bt1.clicked.connect(self.showMessage) #clicked.connect的参数表示当我们点击按钮时要执行的操作 #(这个例子中表示调用self.showMessage这个函数) self.text = QLineEdit('在这里输入数字', self) #QLineEdit表示文本输入框，第一个参数为输入框中的信息， #第二个参数表示绑定在example这个实例上 self.text.selectAll() #selectAll代表一开始就全选，不是必要函数，只是为了方便输入。 #如果没有这个函数调用，我们输入数字之前要手动的逐个把 #'在这里输入数字'的内容去除 self.text.setFocus() #setFocus是为了设置焦点，简单来说就是 #当我们点击程序中的其他地方，都可以直接在输入框中打字 #不是必要函数，去除的话当我们要输入数字，就必须点击输入框 self.text.setGeometry(80, 50, 150, 30) self.show() #show是必要函数，是为了让我们前面设置的内容都能在程序中显示 def showMessage(self): guessnumber = int(self.text.text()) #self.text.text()可以返回我们输入的信息 #因为是以string返回，所以要比较之前要转换成int print(self.num) #这是为了显示随机的数字是多少，打印在面板中 if guessnumber &gt; self.num: QMessageBox.about(self, '看结果', '猜大了!') #about表示弹出的信息，第一个参数代表函数绑定在example #第二个参数是title，第三个是文本内容 self.text.setFocus() #非必要函数， elif guessnumber &lt; self.num: QMessageBox.about(self, '看结果', '猜小了!') self.text.setFocus() else: QMessageBox.about(self, '看结果', '答对了!进入下一轮!') self.num = randint(1, 100) self.text.clear() #self.text.clear可以清除我们输入的内容 self.text.setFocus() def closeEvent(self, event): reply = QMessageBox.question(self, '确认', '确认退出吗', QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if reply == QMessageBox.Yes: event.accept() else: event.ignore()if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) closeEvent这个函数要放在最后讲，应该是文章中最复杂的一部分了。整篇文章看下来似乎没有地方调用到这个函数这是因为这个函数是本身就存在了，所以如果我们点击了退出就会自动调用(如果我们没有设置这个函数)所以我们相当于修改了程序中默认的closeEvent函数，改成了我们想要的函数这样当我们点击退出就会自动调用我们自定义的closeEvent，event.accept()表示事件通过，成功退出event.ignore()表示忽略时间，当我们点击取消的时候event.ignore()是很有必要的，如果没有加入这个函数，我们点击了取消程序也会自动退出]]></content>
      <categories>
        <category>PyQt5</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[想摆脱父母想变强大的黑魔法师]]></title>
    <url>%2FJeaDong.github.io%2F2018%2F06%2F05%2F%E6%83%B3%E6%91%86%E8%84%B1%E7%88%B6%E6%AF%8D%E6%83%B3%E5%8F%98%E5%BC%BA%E5%A4%A7%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95%E5%B8%88%2F</url>
    <content type="text"><![CDATA[这几天好房子找的很心累，原本应该拿来写程序和看书的时间都没有了而且有点生气吧，因为真的很讨厌被打乱节奏。我明明可以保持每天6-7小时的学习时间的。然后我就有点想找人发牢骚了，本来是不打算那么快就告诉我妈的。我妈和我说找不到就回家也行，可是我不听。我才回去，如果我回去了，就少了两个月，起码我现在很想体验真正的工作流程。而且，我也想赚更多的钱。这样等我有钱了我就可以自己拿定更多的主意了，起码我如果自己过得好，我爸妈就不会太干预我的婚姻（至少我现在是这么想的）那一天被我妈’骚扰‘了很多次，最后她问了我。是不是怕我们一直管你让你不自由，回来不好吗？我当然回答不是了，虽然从结果上看是这样。我后来想了一下我确实不想要他们管着我，干预我以后的感情。如果我一直做一个听话的宝宝，或许会过的很普通，当然没什么不好。可是这个世界那么多，那么多有趣的人。想起来我妈已经给我介绍过两个对象了，哎。听说最近还物色了一个，后来我爸看了下觉得不怎么样，就没有告诉我。我也是最近才知道的。我妈总会告诉我取本地老婆多好，可是这一点我怎么会不知道呢？ 努力学习黑魔法才是我现在应该做的事情最后我才有资本去过好自己的生活，有自己喜欢的人，也可以不让父母担心 诸君，加油吧]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>黑魔法师之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次寻找实习的经历]]></title>
    <url>%2FJeaDong.github.io%2F2018%2F06%2F01%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BE%E5%AE%9E%E4%B9%A0%E7%9A%84%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前一天的忐忑复习算法，数据结构，准备面试问题，复述项目那天晚上，我把常见的数据结构都重新手写了一遍，以及各种常见的排序，查找算法实现了一遍。说实话，如果考算法我一点都不虚，几乎普通公司只会考到Leetcode上面的easy难度的题目，我很有自信可以完全胜任 技术面如同上面完成了，然后就是HR或许会问到一些可能会问到的问题，我结合自身经历练习着复述我应该讲给HR听的内容。当时我准备了可能会问缺点，我会说我可能会比较冲动，粗心。再结合实际经历说明我是如何解决的（比如粗心可以通过review和笔记提醒）,再比如准备我的优势：结合自身经历，比如我可以根据以前学的一些逻辑，直接举一反三完成了一个论坛所需要的功能，从而突显出我的学习能力 迟到，焦虑，迷路我实际上已经以前一个多小时去搭校车了，恶心的等车加上堵车让我慢了半小时。我开始担心，我不喜欢迟到，而且这会给别人留下不好印象，好在我提前和HR说了我可能会晚一些到（希望你们也如此，至少让对方心里有数，不至于瞎等） 辗转反侧，最后终于到达了地图上的位置！再次迷路，之前在地铁上迷路一次，出站的时候迷路一次，这次是错跑到广场，其实我应该去隔壁的写字楼，汗！！！ 历经千辛万苦，终于到达目的地啦。啊天哪前台的小姐姐问我有没有简历？什么！还要简历，不是有电子版嘛~~然后小姐姐就强行要我填一份，emmm，填完后小姐姐一脸疑惑问我没有项目吗？？当然是都写在电子版上面啦 好奇心在等待小姐姐帮我联系主管帮我面试的时候，我一直观察着旁边的人在干什么右边小哥哥正在用PR编辑视频，嘿，小哥哥很认真，桌子上还有一台自己的摄像机左边的小姐姐在上网，虽然不知道她在干嘛重点是我前方那个老哥居然在看游戏直播，天哪这是在工作耶！这是酱油还是学习啊？感觉对这个工作环境充满的好奇心 口头offer终于轮到我面试了，没有技术面，没有HR面（哈哈好像准备的都没用上呢）主管直接面试的我，先简单和他聊了一下，比如为啥来广州啊，佛山离这里远不远啊，是不是真的喜欢写程序啊！！后来就问我Python都在做什么事情终于开始我的表演了：我把我写的两个项目，从一开始到后台的逻辑开发到服务器的部署，完完整整的表述的出来，主管表示很满意，接着继续聊天，问我对工资有没有要求（哎我说没有）因为我是真不知道要多少，没有参照。整个聊天过程很愉快，我整个过程都在留意他说的每一句话，判断他是不是有画大饼的嫌疑，不断客观分析，不断对他说的每一句话进行判断，并提出问题。中间巴拉巴拉了一点我也忘记了，最后他给我的忠告就是这个行业如果不是真的喜欢，还是不要来好，加班是常态，希望我想清楚自己是不是真的喜欢写程序。聊天差不多要结束的时候，他已经口头上说了放假就可以来了。可是我觉得还没实际给offer不稳，准备跟他要的时候他刚好说了晚点会发给我。 早上面试完后下午就去和同学玩啦，吃饭的时候HR打电话过来询问了具体信息，然后我就大概收到了邮箱发来的offer了 最后我其实面试完一直在纳闷，我的天哪为什么那么简单？？难道我项目写的太好说的太好？我觉得还没把我会的那些原理，数据结构，算法基础都展现出来啊！（想想有点亏，但是知足啦其实）可能对方也没给多大的压力，我面试已经刚进去后的10分钟后都保持着很自信的状态，因为接受过培训的原因，我真的不觉得我会比他们公司的正式程序员差到哪至少我相信教会我很多东西的导师，因为他真的是一个很厉害的人，也经常告诉我不要妄自菲薄，他教出来的学生面对一开始的工作完全绰绰有余。 机会都是自己争取的，那些公司上面都没有写要招实习生，而且我才大三很多人不要，因为我只有两个月可以实习，大概幸运女神眷顾，让我那么轻易就拿到了一个offer储君，加油吧！儿童节面试的，还给自己买个只小熊作为礼物，觉得自己棒棒哒！！！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>黑魔法师之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树实现，遍历]]></title>
    <url>%2FJeaDong.github.io%2F2018%2F05%2F31%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%8C%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树数据结构的实现以及各种遍历12345class Node(object):#创建节点类型 def __init__(self,item): self.elem = item#节点的值 self.lchild = None#左节点 self.rchild = None#右节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Tree(object): def __init__(self):#默认的根节点是None self.root = None def add(self,item):#添加新节点 node = Node(item) if self.root is None:#表示第一个添加的节点 self.root = node return queue = [self.root]#队列储存节点 while queue: cur_node = queue.pop(0)#返回队列的第一个节点 if cur_node.lchild == None:#该节点的左子节点为None时，添加到该子节点上 cur_node.lchild = node return else: queue.append(cur_node.lchild)#添加左子节点到队列，方便后续调用 if cur_node.rchild == None: cur_node.rchild = node return else: queue.append(cur_node.rchild) def breach_travel(self):#广度遍历 if self.root == None: return queue = [self.root] while queue: cur_node = queue.pop(0) if cur_node.lchild: queue.append(cur_node.lchild) if cur_node.rchild: queue.append(cur_node.rchild) print(cur_node.elem) def preorder(self,tree):#前序遍历 if tree == None: return print(tree.elem) self.preorder(tree.lchild) self.preorder(tree.rchild) def midorder(self,tree):#中序遍历 if tree == None: return print(tree.elem) self.midorder(tree.lchild) self.midorder(tree.rchild) def postorder(self,tree):#后续遍历 if tree == None: return print(tree.elem) self.postorder(tree.lchild) self.postorder(tree.rchild)###二叉树的重建def ReBuild(pre,mid): if len(pre) == 0: return if len(pre) == 1: return Node(pre[0]) else: root_val = pre[0] root_position = mid.index(root_val) root = Node(root_val) root.lchild = ReBuild(pre[1:root_position+1],mid[:root_position]) root.rchild = ReBuild(pre[root_position+1:],mid[root_position+1:]) return rootif __name__ == '__main__': tree = Tree()#创建二叉树实例 for i in range(10):#循环从列表中添加子节点 tree.add(i) print('breach_travel') tree.breach_travel() print('preorder') tree.preorder(tree.root) print('midorder') tree.midorder(tree.root) print('postorder') tree.postorder(tree.root)]]></content>
      <categories>
        <category>数据结构 算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找实现]]></title>
    <url>%2FJeaDong.github.io%2F2018%2F05%2F31%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[二分查找这其实是一个很重要的方法，速度很快，数据库中的索引也是用到这种方法123456789101112def binary_search(alist,item): '''递归版本''' n = len(alist) if n &gt; 0: mid = n//2 if alist[mid] == item: return True elif item &lt; alist[mid]: return binary_search(alist[:mid],item) else: return binary_search(alist[mid+1:],item) return False 12345678910111213141516def binary_search_2(alist,item): '''非递归版本''' n = len(alist) first = 0 last = n - 1 while first &lt;= last: mid = (first + last)//2 if alist[mid] == item: return True elif item &lt; alist[mid]: last = mid - 1 else: first = mid + 1 return False''' O(1) O(logn)''']]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法的实现]]></title>
    <url>%2FJeaDong.github.io%2F2018%2F05%2F31%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[冒泡排序1234567891011def bubble_sort(alist): '''冒泡排序''' for j in range(len(alist) - 1): for i in range(len(alist) - 1 - j): if alist[i] &gt; alist[i + 1]: alist[i], alist[i + 1] = alist[i + 1], alist[i] return alist#O(n) O(n^2) 稳定 选择排序1234567891011121314151617def select_sort(alist): '''选择排序''' for j in range(len(alist) - 1): min_index = j for i in range(j, len(alist)): if alist[min_index] &gt; alist[i]: min_index = i alist[j], alist[min_index] = alist[min_index], alist[j] return alist'''O(n^2) O(n^2) 不稳定''' 插入排序123456789101112131415161718192021def insert_sort(alist): '''插入排序''' for j in range(1, len(alist)): i = j while i &gt; 0: if alist[i] &lt; alist[i - 1]: alist[i], alist[i - 1] = alist[i - 1], alist[i] i -= 1 else: break return alist''' O(n) O(n^2) 稳定''' 归并排序123456789101112131415161718192021def merge_sort(alist): n = len(alist) mid = n // 2 if n &lt;= 1: return alist mid = n // 2 left_li = merge_sort(alist[:mid]) right_li = merge_sort(alist[mid:]) left_pointer, right_pointer = 0, 0 result = [] while left_pointer &lt; len(left_li) and right_pointer &lt; len(right_li): if left_li[left_pointer] &lt; right_li[right_pointer]: result.append(left_li[left_pointer]) left_pointer += 1 else: result.append(right_li[right_pointer]) right_pointer += 1 result += left_li[left_pointer:] result += right_li[right_pointer:] return result ''' O(nlogn) O(nlogn) 稳定''' 快速排序12345678910111213141516171819202122232425262728293031323334def quick_sort(alist, first, last):#这是迭代解法 if first &gt;= last: return mid = alist[first] low = first high = last while low &lt; high: while low &lt; high and alist[high] &gt;= mid: high -= 1 alist[low] = alist[high] while low &lt; high and alist[low] &lt; mid: low += 1 alist[high] = alist[low] alist[low] = mid quick_sort(alist, first, low - 1) quick_sort(alist, low + 1, last)def quicksort(array):#这是递归解法，看着代码量少了很多 if len(array) &lt; 2: return array else: pivot = array[0] less = [i for i in array[1:] if i &lt;= pivot] greater = [i for i in array[1:] if i &gt; pivot] return (quicksort(less) + [pivot] + quicksort(greater))''' O(logn) O(logn) 不稳定''']]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket 客户端篇]]></title>
    <url>%2FJeaDong.github.io%2F2018%2F05%2F25%2Fsocket%2F</url>
    <content type="text"><![CDATA[1import socket socket这个模块是重点，其中包含了我们需要的TCP/UDP连接方式,以及ipv4/ipv6,简而言之, 就是发送 / 接收数据1s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 这是为了创建一个socket对象(socket是一个类)socket.AF_INET表示是 ipv4 协议socket.SOCK_STREAM 表示是 tcp 协议这两个值都是默认值，所以也可以写成 s = socket.socket()如果不是很了解tcp协议可以看一下我之前写的文章123host = 'g.cn'port = 80s.connect((host, port)) host表示你要访问的地址，比如写成baidu.com也可以port表示默认端口,如果是在HTTPS协议下，要设置为443最后用connect建立连接,注意到参数是一个tuple1http_request = ('GET / HTTP/1.1\r\nHost:&#123;&#125;\r\n\r\n'.format(host)) http_request可以构建出一个http的头部,在这个例子中表示:GET / HTTP/ 1.1Host : g.cn123request = http_request.encode('utf-8')print('请求', request)s.send(request) 因为我们传输数据只能通过二进制进行传输，所以我们要先对我们要发送的字符串请求进行utf-8编码后再用send发送到服务器(g.cn)发送完请求后我们就要开始接收数据啦1response = s.recv(1024) 可以用于接收数据,我们设置每次只接收1024字节当然，如果接收的数据超过1024个字节我们就不能接收到后面的数据了，所以我们需要创建一个循环要不断接收数据，知道接收完毕123456789101112# 接收数据:buffer = []while True: # 每次最多接收1k字节: response = s.recv(1024) if response: buffer.append(response) else: breakdata = b''.join(buffer)# 关闭连接:s.close() 当接收完毕时，response为None，退出循环。也可以用recv(max)一次接收完所有数据。最后调用close()关闭连接这就完成了一次TCP连接。TCP可以保证数据的完整性12345header, html = data.split(b'\r\n\r\n', 1)print(header.decode('utf-8'))# 把接收的数据写入文件:with open('谷歌.html', 'wb') as f: f.write(html) 这样就可以打开谷歌.html这个文件查看接收的内容了]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反转链表]]></title>
    <url>%2FJeaDong.github.io%2F2018%2F05%2F23%2F%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[反转链表123456789class Node(): def __init__(self,val): self.val = val self.next = Noneclass Link(): def __init__(self,val): self.__name__ = Node(val) 第一部分是用迭代方法12345678910111213def ReverseLink(link): p = None q = t = link#we need 3 pointer to pertect the link list while t.next: t = t.next q.next = p p = q q = t #print(t.val) q.next = p return t '''a[1,2,3], b[2,4,5] ''' 第二部分是用递归方法递归看起来简洁，但是没有迭代那么好理解123456def ReverseLink(head,last=None): if not head: return last next = head.next head.next = last return ReverseLink(next,head)]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷 leetcode 需要哪些基础？]]></title>
    <url>%2FJeaDong.github.io%2F2018%2F05%2F22%2F%E5%88%B7-leetcode-%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E5%9F%BA%E7%A1%80%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[说实话，只需要你懂基本语法和正常的逻辑 我记得我第一次leetcode的时候，连简单的sort都不会（那时候真觉得自己菜），但是没关系，直接去discuss区看一下别人是怎么解的，只要你看得懂，看多了再结合场景你也就可以写出来了，至少对于easy难度是这样。 刷leetcode最大的收益除了熟悉一些数据结构，涨了见识（就像是数学，当你第一次看到神奇的解法，会感叹到what the magic solution！）后来我实际做开发项目了，代码中写list，set，dict以及loop的风格都是继承自leetcode时的风格，而且都是很简洁的表达出来，这是leetcode带给我开发时最大的好处。]]></content>
      <categories>
        <category>心得</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP 为什么是三次握手，而不是两次或四次？]]></title>
    <url>%2FJeaDong.github.io%2F2018%2F05%2F22%2FTCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%88%96%E5%9B%9B%E6%AC%A1%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[三次握手和四次握手是等价的，区别只是三次握手把ACK和SYN一并发送了，四次就是分开发送。 这个过程主要解决了三个问题：1.确认接受方的存在2.统一双方协商的协议（服务质量，最大接受等）3.对运输实体（比如缓存，连接表中的项目）进行分配如果只考虑单方面传输（实际为全双工），设A》》》B，最初A，B都处于 关闭close 状态。 A主动打开连接，创建传输控制模块TCB，在建立TCP连接时（B为被动连接）。 这是B如果同意建立连接，就会向A发动确认信息 A再收到B的确认信息时也要返回确认信息 这就是三次握手了 至于最后一步为什么A还要向B发送确认信息，是为了保证连接的正确无误（有可能出现 A发送的请求延时后再发送第二份请求，之后B收到第二份请求最后也完成了释放连接，重点来了，此时延时的第一份请求到了B，B就又建立了一个新连接，并发送确认信息，如果没有最后一步返回确认信息，B会一直等待A的返回信息而占用连接资源） 细节可以参考《计算机网络 第7版》谢教授的多吐槽一句，我们老师上课一直wuli谢希仁前wuli谢希仁后，但是考试的时候全泥煤不考书上的东西，生气！！！]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 协议到底在讲什么？]]></title>
    <url>%2FJeaDong.github.io%2F2018%2F05%2F22%2FTCP-IP%E5%AD%98%E5%9C%A8%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[正好在上《计算机网络》这门课，试着回答，也整理下思路为了之后的面试假设没有IP协议，全世界的网络通信会变得很麻烦，比如要考虑路由选择，寻址方案，差错修复方法等N多问题，是不是很麻烦？就好像一个班里面有的同学说客家话，有的说粤语，有的说潮汕话，各说各的还这么好好聊天哇？你最多只能听懂一点。ok普通话的作用就来了，大家都用普通话，是不是交流就easy了，比如我听我同学讲粤语，我最多听懂50%，内心OS：what the hellQAQ！ 这就像是没有IP协议时的情况，所以IP协议也就完成了这个统一（从此世界和平）讲TCP前，要先讲一下为什么需要TCP！上古时代（中二）人们电话间的通信是使用 交换机，自然到了网络时代优先想到的也是这个方法，好处就是交换机可以 无差错按序到达接受方 。哇那么好用的东西为什么人类要犯贱呢？因为贵！ 后来人类发现计算机没有像电话机那么弱智，连差错处理这种能力都没有！！！既然有这个能力，我们就要好好利用，这时就使用了 路由器 代替 交换机，这样网络造价方面就降低了，便宜谁不想要呢。 当然便宜的好处可能也只是便宜了，使用了路由器后，网络层不再提供质量保证的服务，也就是说你传输的数据会出错，丢失，失序等 这时TCP就登场了（位于网络层之上），它保证数据的完整性。TCP会在发送的数据都标记序号，逐个发送数据片段，接受方收到数据段后会确认序号是否正确，错误的话就丢弃数据并发送确认请求，接受方只要发现数据序号不对就会重新发送之前没有收到确认信息的数据。（这就保证了数据的有序完整） TCP中还有很多机制，比如超时重传，如果发送方发送的数据堵在了某个地方，那么过一段时间（超时了）就会重新发送这份数据，只有受到接受方的确认信息才会发送下一份数据片段。详细可以看下《计算机网络 第七版》这本书]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
</search>
